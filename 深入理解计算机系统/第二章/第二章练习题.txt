2.1
A. 0011 1001 1010 0111 1111 1000
B. 0xC97B
C. 1101 0101 1110 0100 1100 
D. 0x26E7B5

2.2
x = 2^n,	n = i + 4j

n	2^n(10)	2^n(16)
9	512		0x200		9 = 1 + 4 * 2
19	524288	0x80000		19 = 3 + 4 * 4
14	16384	0x4000		14 = 2 + 4 * 3
16	65536	0x10000		16 = 0 + 4 * 4
17	131072	0x20000		17 = 1 + 4 * 4
5	32		0x20        5 = 1 + 4 * 1
7	128		0x80      	7 = 3 + 4 * 1

2.3
十		二			十六
0		0000 0000	0x00
167		1010 0111	0xA7
62		0011 1110	0x3E
188		1011 1100	0xBC
55		0011 0111	0x37
136		1000 1000	0x88
243		1111 0011	0xF3
82		0101 0010	0x52
172		1010 1100	0xAC
231		1110 0111	0xE7

2.4
A. 0x5044
B. 0x4FFC
C. 0x507c
D. 0xAE

2.5
A. 21		87
B. 2143		8765
C. 214365	876543

2.6
0000 0000 0011 0101 1001 0001 0010 0001 

  0100 1010 0101 0110 0100 0101 0000 0100

 整数部分除最高位1外与浮点数匹配，浮点数高位不匹配

2.7
61 62 63 64 65 66 

2.8
~a 		10010110
~b 		10101010
a & b 	01000001
a | b 	01111101
a ^ b 	00111100

2.9
A. 黑-白 蓝-黄 绿-红紫 蓝绿-红
B. 蓝绿 绿 蓝

2.10
步骤		*x		*y
初始		a 		b
第1步	a 		a ^ b
第2步	b 		a ^ b
第3步 	b 		a

2.11
A. first = last = k
B. a[k] ^ a[k] = 0
C. (first <= last) -> (first < last)

2.12*
A. x = x & 0xFF
B. x = x ^ ~0xFF
C. x = x | 0xFF

2.13*
bool_or: result = bis(x, y)
bool_xor: result = bis(bic(x, y), bic(y, x))

2.14
x 	0x66 	0110 0110	
y 	0x39	0011 1001

x & y 	0010 0000 	0x20
x | y 	0111 1111 	0x7F
~x | ~y 	1101 1111 0xDF
x & !y 	0x00

x && y 	0x01
x || y 	0x01
!x || !y 	0x00
x && ~y 	0x01

2.15
!(x & ~y) !(x ^ y)

2.16
x 				  	x << 3			 	x >> 2 (逻辑) 	 	x >> 2 (算术)	
0xC3 	1100 0011 	0001 1000 	0x18	0011 0000 	0x30	1111 0000 	0xF0
0x75 	0111 0101 	1010 1000 	0xA8 	0001 1101 	0x1D	0001 1101 	0x1D
0x87 	1000 0111 	0011 1000 	0x38 	0010 0001 	0x21	1110 0001 	0xE1
0x66 	0110 0110 	0011 0000 	0x30 	0001 1001 	0x19	0001 1001 	0x19

2.17
0xE 	1110 	14 	-2
0x0 	0000 	0 	0
0x5 	0101 	5 	5
0x8 	1000 	8 	-8
0xD 	1101 	13 	-3
0xF 	1111 	15	-1

2.18
A. 736
B. -88
C. 40
D. -48
E. 120
F. 136
G. 504
H. 8 192
I. -56

2.19
-8 	8
-3 	13
-2 	14
-1 	15
0 	0
5 	5

2.20

2.21
无符号 	1
有符号 	1
无符号 	0
有符号 	1
无符号 	1

2.22

2.23
A.
0x00000076 	0x00000076
0x00000021 	0x00000021
0x000000C9 	0xFFFFFFC9
0x00000087 	0xFFFFFF87
B. fun1: 保留最低位字节	fun2: 保留最低位字节并保证符号不变

2.24
0	0
2	2
1	1
3	3
7	-1

2.25
无符号数和有符号数运算，默认转变为无符号数，0 <= 0xFFFFFFFF
unsigned -> int

2.26
A. s长度小于t长度
B. unsigned int只能表示非负数
C. strlen(s) > strlen(t)

2.27
int uadd_ok (unsigned x, unsigned y) {
	unsigned s = x + y;
	if (s < x) {
		return 0;
	}
	return 1;
}  

2.28
0 	0 	0 	0
5 	5 	11 	B
8 	8 	8 	8
D 	13 	3 	3
F 	15 	1 	1

2.29
10100	10001	100101	00101	1
11000	11000	110000	10000	2

2.30
int tadd_ok(int x, int y) {
	int s = x + y;
	int neg_over = x < 0 && y < 0 && s >= 0;
	int pos_over = x >= 0 && y >= 0 && s < 0;
	return !neg_over && !pos_over;
}

2.31*
总是成立

2.32
y = -INT_MAX - 1

2.33
0	0	0	0
5	5	-5	B
8	-8	-8	8
D 	-3	3	3
F 	-1	1	1

2.35

2.36
int tmult_ok(int x, int y) {
	int_64 p = (int_64) x * y;
	return p == (int_32) p;
}

2.37
A. 没有改进，asize被强制转换为32位，溢出
B. 检查是否溢出，是则直接返回

2.38
1、2、3、4、5、8、9

2.39
-(x<<m)

2.40
x<<2 + x<<1
x<<5 - x
x<<1 - x<<3
x<<6 - x<<3 - x

2.41
if (n == m) {
	A;
} else if (n == m + 1) {
	A or B;
} else if (n > m + 1) {
	B;
}

2.42
int div16 (int x) {
	int bias = (x >> 31) && 0xF;
	return (x + bias) >> 4;
}

2.43
M=31, N=8

2.44
A. x = INT_MIN
B. 
C. x * x > INT_MAX
D. 
E. x = INT_MIN
F. 
G. 

2.45
1/8 	0.001 	0.125
3/4 	0.11 	0.75
25/16 	1.1001 	1.5625
43/16 	10.1011 	2.6875
9/8 	1.001 	1.125
47/8 	101.111 	5.875
51/16 	11.0011 	3.1875

2.46
A. 0.0000000000000000000000011001100...
B. 1.5*2^-24
C. 100*3600*1.5*2^-24*10 = 0.3s
D. 2000*0.3 = 600


